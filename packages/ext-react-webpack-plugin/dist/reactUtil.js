"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getValidateOptions = getValidateOptions;
exports.getDefaultOptions = getDefaultOptions;
exports.getDefaultVars = getDefaultVars;
exports.extractFromSource = extractFromSource;

function getValidateOptions() {
  return {
    "type": "object",
    "properties": {
      "framework": {
        "type": ["string"]
      },
      "port": {
        "type": ["integer"]
      },
      "emit": {
        "type": ["boolean"]
      },
      "browser": {
        "type": ["boolean"]
      },
      "profile": {
        "type": ["string"]
      },
      "environment": {
        "type": ["string"]
      },
      "verbose": {
        "type": ["string"]
      },
      "theme": {
        "type": ["string"]
      },
      "toolkit": {
        "type": ["string"]
      },
      "packages": {
        "type": ["string", "array"]
      }
    },
    "additionalProperties": false // "errorMessage": {
    //   "option": "should be {Boolean} (https:/github.com/org/repo#anchor)"
    // }

  };
}

function getDefaultOptions() {
  return {
    port: 1962,
    emit: true,
    browser: true,
    profile: '',
    environment: 'development',
    verbose: 'no',
    toolkit: 'modern',
    packages: null
  };
}

function getDefaultVars() {
  return {
    firstTime: true,
    firstCompile: true,
    browserCount: 0,
    manifest: null,
    extPath: 'ext-react',
    pluginErrors: [],
    deps: [],
    rebuild: true
  };
}

function toXtype(str) {
  return str.toLowerCase().replace(/_/g, '-');
}

function extractFromSource(js) {
  var generate = require("@babel/generator").default;

  var parse = require("babylon").parse;

  var traverse = require("ast-traverse");

  const statements = [];
  const ast = parse(js, {
    plugins: ['jsx', 'flow', 'doExpressions', 'objectRestSpread', 'classProperties', 'exportExtensions', 'asyncGenerators', 'functionBind', 'functionSent', 'dynamicImport'],
    sourceType: 'module'
  });

  function addType(argNode) {
    var type;

    if (argNode.type === 'StringLiteral') {
      var xtype = toXtype(argNode.value);

      if (xtype != 'extreact') {
        type = {
          xtype: toXtype(argNode.value)
        };
      }
    } else {
      type = {
        xclass: js.slice(argNode.start, argNode.end)
      };
    }

    if (type != undefined) {
      let config = JSON.stringify(type);
      statements.push(`Ext.create(${config})`);
    }
  }

  traverse(ast, {
    pre: function (node) {
      if (node.type === 'CallExpression' && node.callee && node.callee.object && node.callee.object.name === 'Ext') {
        statements.push(generate(node).code);
      }

      if (node.type == 'VariableDeclarator' && node.init && node.init.type === 'CallExpression' && node.init.callee) {
        if (node.init.callee.name == 'reactify') {
          for (let i = 0; i < node.init.arguments.length; i++) {
            const valueNode = node.init.arguments[i];
            if (!valueNode) continue;
            addType(valueNode);
          }
        }
      } // // Convert React.createElement(...) calls to the equivalent Ext.create(...) calls to put in the manifest.
      // if (node.type === 'CallExpressionx' 
      //     && node.callee.object 
      //     && node.callee.object.name === 'React' 
      //     && node.callee.property.name === 'createElement') {
      //   const [props] = node.arguments
      //   let config
      //   if (Array.isArray(props.properties)) {
      //     config = generate(props).code
      //     for (let key in type) {
      //       config = `{\n  ${key}: '${type[key]}',${config.slice(1)}`
      //     }
      //   } else {
      //     config = JSON.stringify(type)
      //   }
      // }

    }
  });
  return statements;
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9yZWFjdFV0aWwuanMiXSwibmFtZXMiOlsiZ2V0VmFsaWRhdGVPcHRpb25zIiwiZ2V0RGVmYXVsdE9wdGlvbnMiLCJwb3J0IiwiZW1pdCIsImJyb3dzZXIiLCJwcm9maWxlIiwiZW52aXJvbm1lbnQiLCJ2ZXJib3NlIiwidG9vbGtpdCIsInBhY2thZ2VzIiwiZ2V0RGVmYXVsdFZhcnMiLCJmaXJzdFRpbWUiLCJmaXJzdENvbXBpbGUiLCJicm93c2VyQ291bnQiLCJtYW5pZmVzdCIsImV4dFBhdGgiLCJwbHVnaW5FcnJvcnMiLCJkZXBzIiwicmVidWlsZCIsInRvWHR5cGUiLCJzdHIiLCJ0b0xvd2VyQ2FzZSIsInJlcGxhY2UiLCJleHRyYWN0RnJvbVNvdXJjZSIsImpzIiwiZ2VuZXJhdGUiLCJyZXF1aXJlIiwiZGVmYXVsdCIsInBhcnNlIiwidHJhdmVyc2UiLCJzdGF0ZW1lbnRzIiwiYXN0IiwicGx1Z2lucyIsInNvdXJjZVR5cGUiLCJhZGRUeXBlIiwiYXJnTm9kZSIsInR5cGUiLCJ4dHlwZSIsInZhbHVlIiwieGNsYXNzIiwic2xpY2UiLCJzdGFydCIsImVuZCIsInVuZGVmaW5lZCIsImNvbmZpZyIsIkpTT04iLCJzdHJpbmdpZnkiLCJwdXNoIiwicHJlIiwibm9kZSIsImNhbGxlZSIsIm9iamVjdCIsIm5hbWUiLCJjb2RlIiwiaW5pdCIsImkiLCJhcmd1bWVudHMiLCJsZW5ndGgiLCJ2YWx1ZU5vZGUiXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7Ozs7O0FBRU8sU0FBU0Esa0JBQVQsR0FBOEI7QUFDbkMsU0FBTztBQUNMLFlBQVEsUUFESDtBQUVMLGtCQUFjO0FBQ1osbUJBQWU7QUFBQyxnQkFBUSxDQUFFLFFBQUY7QUFBVCxPQURIO0FBRVosY0FBZTtBQUFDLGdCQUFRLENBQUUsU0FBRjtBQUFULE9BRkg7QUFHWixjQUFlO0FBQUMsZ0JBQVEsQ0FBRSxTQUFGO0FBQVQsT0FISDtBQUlaLGlCQUFlO0FBQUMsZ0JBQVEsQ0FBRSxTQUFGO0FB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QUFDaEJ4QixZQUFBQSxPQUFPLENBQUN3QixTQUFELENBQVA7QUFDRDtBQUNEO0FBQ0gsT0FwQmlCLENBc0JsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDRDtBQXZDVyxHQUFOLENBQVI7QUF5Q0EsU0FBTzVCLFVBQVA7QUFDRCIsInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiXG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRWYWxpZGF0ZU9wdGlvbnMoKSB7XG4gIHJldHVybiB7XG4gICAgXCJ0eXBlXCI6IFwib2JqZWN0XCIsXG4gICAgXCJwcm9wZXJ0aWVzXCI6IHtcbiAgICAgIFwiZnJhbWV3b3JrXCI6ICAge1widHlwZVwiOiBbIFwic3RyaW5nXCIgXX0sXG4gICAgICBcInBvcnRcIjogICAgICAgIHtcInR5cGVcIjogWyBcImludGVnZXJcIiBdfSxcbiAgICAgIFwiZW1pdFwiOiAgICAgICAge1widHlwZVwiOiBbIFwiYm9vbGVhblwiIF19LFxuICAgICAgXCJicm93c2VyXCI6ICAgICB7XCJ0eXBlXCI6IFsgXCJib29sZWFuXCIgXX0sXG4gICAgICBcInByb2ZpbGVcIjogICAgIHtcInR5cGVcIjogWyBcInN0cmluZ1wiIF19LFxuICAgICAgXCJlbnZpcm9ubWVudFwiOiB7XCJ0eXBlXCI6IFsgXCJzdHJpbmdcIiBdfSxcbiAgICAgIFwidmVyYm9zZVwiOiAgICAge1widHlwZVwiOiBbIFwic3RyaW5nXCIgXX0sXG4gICAgICBcInRoZW1lXCI6ICAgICAgIHtcInR5cGVcIjogWyBcInN0cmluZ1wiIF19LFxuICAgICAgXCJ0b29sa2l0XCI6ICAgICB7XCJ0eXBlXCI6IFsgXCJzdHJpbmdcIiBdfSxcbiAgICAgIFwicGFja2FnZXNcIjogICAge1widHlwZVwiOiBbIFwic3RyaW5nXCIsIFwiYXJyYXlcIiBdfVxuICAgIH0sXG4gICAgXCJhZGRpdGlvbmFsUHJvcGVydGllc1wiOiBmYWxzZVxuICAgIC8vIFwiZXJyb3JNZXNzYWdlXCI6IHtcbiAgICAvLyAgIFwib3B0aW9uXCI6IFwic2hvdWxkIGJlIHtCb29sZWFufSAoaHR0cHM6L2dpdGh1Yi5jb20vb3JnL3JlcG8jYW5jaG9yKVwiXG4gICAgLy8gfVxuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXREZWZhdWx0T3B0aW9ucygpIHtcbiAgcmV0dXJuIHtcbiAgICBwb3J0OiAxOTYyLFxuICAgIGVtaXQ6IHRydWUsXG4gICAgYnJvd3NlcjogdHJ1ZSxcbiAgICBwcm9maWxlOiAnJywgXG4gICAgZW52aXJvbm1lbnQ6ICdkZXZlbG9wbWVudCcsIFxuICAgIHZlcmJvc2U6ICdubycsXG4gICAgdG9vbGtpdDogJ21vZGVybicsXG4gICAgcGFja2FnZXM6IG51bGxcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0RGVmYXVsdFZhcnMoKSB7XG4gIHJldHVybiB7XG4gICAgZmlyc3RUaW1lIDogdHJ1ZSxcbiAgICBmaXJzdENvbXBpbGU6IHRydWUsXG4gICAgYnJvd3NlckNvdW50IDogMCxcbiAgICBtYW5pZmVzdDogbnVsbCxcbiAgICBleHRQYXRoOiAnZXh0LXJlYWN0JyxcbiAgICBwbHVnaW5FcnJvcnM6IFtdLFxuICAgIGRlcHM6IFtdLFxuICAgIHJlYnVpbGQ6IHRydWVcbiAgfVxufVxuXG5cblxuXG5mdW5jdGlvbiB0b1h0eXBlKHN0cikge1xuICByZXR1cm4gc3RyLnRvTG93ZXJDYXNlKCkucmVwbGFjZSgvXy9nLCAnLScpXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBleHRyYWN0RnJvbVNvdXJjZShqcykge1xuICB2YXIgZ2VuZXJhdGUgPSByZXF1aXJlKFwiQGJhYmVsL2dlbmVyYXRvclwiKS5kZWZhdWx0XG4gIHZhciBwYXJzZSA9IHJlcXVpcmUoXCJiYWJ5bG9uXCIpLnBhcnNlXG4gIHZhciB0cmF2ZXJzZSA9IHJlcXVpcmUoXCJhc3QtdHJhdmVyc2VcIilcbiAgY29uc3Qgc3RhdGVtZW50cyA9IFtdXG4gIFxuICBjb25zdCBhc3QgPSBwYXJzZShqcywge1xuICAgIHBsdWdpbnM6IFtcbiAgICAgICdqc3gnLFxuICAgICAgJ2Zsb3cnLFxuICAgICAgJ2RvRXhwcmVzc2lvbnMnLFxuICAgICAgJ29iamVjdFJlc3RTcHJlYWQnLFxuICAgICAgJ2NsYXNzUHJvcGVydGllcycsXG4gICAgICAnZXhwb3J0RXh0ZW5zaW9ucycsXG4gICAgICAnYXN5bmNHZW5lcmF0b3JzJyxcbiAgICAgICdmdW5jdGlvbkJpbmQnLFxuICAgICAgJ2Z1bmN0aW9uU2VudCcsXG4gICAgICAnZHluYW1pY0ltcG9ydCdcbiAgICBdLFxuICAgIHNvdXJjZVR5cGU6ICdtb2R1bGUnXG4gIH0pXG5cbiAgZnVuY3Rpb24gYWRkVHlwZShhcmdOb2RlKSB7XG4gICAgdmFyIHR5cGVcbiAgICBpZiAoYXJnTm9kZS50eXBlID09PSAnU3RyaW5nTGl0ZXJhbCcpIHtcbiAgICAgIHZhciB4dHlwZSA9IHRvWHR5cGUoYXJnTm9kZS52YWx1ZSlcbiAgICAgIGlmICh4dHlwZSAhPSAnZXh0cmVhY3QnKSB7XG4gICAgICAgIHR5cGUgPSB7IHh0eXBlOiB0b1h0eXBlKGFyZ05vZGUudmFsdWUpIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdHlwZSA9IHsgeGNsYXNzOiBqcy5zbGljZShhcmdOb2RlLnN0YXJ0LCBhcmdOb2RlLmVuZCkgfVxuICAgIH1cbiAgICBpZiAodHlwZSAhPSB1bmRlZmluZWQpIHtcbiAgICAgIGxldCBjb25maWcgPSBKU09OLnN0cmluZ2lmeSh0eXBlKVxuICAgICAgc3RhdGVtZW50cy5wdXNoKGBFeHQuY3JlYXRlKCR7Y29uZmlnfSlgKVxuICAgIH1cbiAgfVxuXG4gIHRyYXZlcnNlKGFzdCwge1xuICAgIHByZTogZnVuY3Rpb24obm9kZSkge1xuICAgICAgaWYgKG5vZGUudHlwZSA9PT0gJ0NhbGxFeHByZXNzaW9uJ1xuICAgICAgICAgICYmIG5vZGUuY2FsbGVlXG4gICAgICAgICAgJiYgbm9kZS5jYWxsZWUub2JqZWN0XG4gICAgICAgICAgJiYgbm9kZS5jYWxsZWUub2JqZWN0Lm5hbWUgPT09ICdFeHQnXG4gICAgICApIHtcbiAgICAgICAgc3RhdGVtZW50cy5wdXNoKGdlbmVyYXRlKG5vZGUpLmNvZGUpXG4gICAgICB9XG4gICAgICBpZiAobm9kZS50eXBlID09ICdWYXJpYWJsZURlY2xhcmF0b3InIFxuICAgICAgICAgICYmIG5vZGUuaW5pdCBcbiAgICAgICAgICAmJiBub2RlLmluaXQudHlwZSA9PT0gJ0NhbGxFeHByZXNzaW9uJyBcbiAgICAgICAgICAmJiBub2RlLmluaXQuY2FsbGVlIFxuICAgICAgKSB7XG4gICAgICAgIGlmIChub2RlLmluaXQuY2FsbGVlLm5hbWUgPT0gJ3JlYWN0aWZ5Jykge1xuICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbm9kZS5pbml0LmFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgdmFsdWVOb2RlID0gbm9kZS5pbml0LmFyZ3VtZW50c1tpXTtcbiAgICAgICAgICAgIGlmICghdmFsdWVOb2RlKSBjb250aW51ZTtcbiAgICAgICAgICAgIGFkZFR5cGUodmFsdWVOb2RlKVxuICAgICAgICAgIH1cbiAgICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gLy8gQ29udmVydCBSZWFjdC5jcmVhdGVFbGVtZW50KC4uLikgY2FsbHMgdG8gdGhlIGVxdWl2YWxlbnQgRXh0LmNyZWF0ZSguLi4pIGNhbGxzIHRvIHB1dCBpbiB0aGUgbWFuaWZlc3QuXG4gICAgICAvLyBpZiAobm9kZS50eXBlID09PSAnQ2FsbEV4cHJlc3Npb254JyBcbiAgICAgIC8vICAgICAmJiBub2RlLmNhbGxlZS5vYmplY3QgXG4gICAgICAvLyAgICAgJiYgbm9kZS5jYWxsZWUub2JqZWN0Lm5hbWUgPT09ICdSZWFjdCcgXG4gICAgICAvLyAgICAgJiYgbm9kZS5jYWxsZWUucHJvcGVydHkubmFtZSA9PT0gJ2NyZWF0ZUVsZW1lbnQnKSB7XG4gICAgICAvLyAgIGNvbnN0IFtwcm9wc10gPSBub2RlLmFyZ3VtZW50c1xuICAgICAgLy8gICBsZXQgY29uZmlnXG4gICAgICAvLyAgIGlmIChBcnJheS5pc0FycmF5KHByb3BzLnByb3BlcnRpZXMpKSB7XG4gICAgICAvLyAgICAgY29uZmlnID0gZ2VuZXJhdGUocHJvcHMpLmNvZGVcbiAgICAgIC8vICAgICBmb3IgKGxldCBrZXkgaW4gdHlwZSkge1xuICAgICAgLy8gICAgICAgY29uZmlnID0gYHtcXG4gICR7a2V5fTogJyR7dHlwZVtrZXldfScsJHtjb25maWcuc2xpY2UoMSl9YFxuICAgICAgLy8gICAgIH1cbiAgICAgIC8vICAgfSBlbHNlIHtcbiAgICAgIC8vICAgICBjb25maWcgPSBKU09OLnN0cmluZ2lmeSh0eXBlKVxuICAgICAgLy8gICB9XG4gICAgICAvLyB9XG4gICAgfVxuICB9KVxuICByZXR1cm4gc3RhdGVtZW50c1xufVxuIl19